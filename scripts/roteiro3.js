const roteiro3 = {
    titulo: "Estrutura de dados e STL",
    num: 3,
    descricao: "Problemas com uso de estrutura de organização de dados (pilhas, filas, conjuntos, etc) e utilização de Standard Template Library de C e C++",
    dificuldade: "média",
    materiais_de_apoio: [
        {
            titulo: "C++ - Referência",
            link: "http://www.cplusplus.com/reference/",
        },
  
        {
            titulo: "Artigo - STL (part 1) (inglês)",
            link: "https://www.topcoder.com/community/competitive-programming/tutorials/power-up-c-with-the-standard-template-library-part-1/",
        },

        {
            titulo: "Artigo - STL (inglês)",
            link: "https://www.topcoder.com/community/competitive-programming/tutorials/power-up-c-with-the-standard-template-library-part-2/",
        },

        {
            titulo: "introdução ao STL",
            link: "http://sweet.ua.pt/joao.p.silva/stl.html",
        },

        {
            titulo: "STL",
            link: "http://www.inf.pucrs.br/~pinho/PRGSWB/STL/stl.html",
        },

        {
            titulo: "Introdução ao STL",
            link: "https://br.ccm.net/faq/10156-introducao-ao-stl-em-c-standard-template-library",
        },

    ],
    problemas: [
      {
        titulo: "Ele está impedido",
        titulo_origem: "URI",
        link_origem: "https://www.urionlinejudge.com.br/judge/pt/problems/view/1410",
        nivel: 3,
        status: true,
        descricao_problema: "Dado um número A de atacantes, e D de defensores de um jogo de futebol, e suas respectivas distâncias para o gol, deve-se responder com 'Y' caso haja um atacante impedido, ou seja, esteja mais próximo do gol do que o penúltimo defensor, ou com 'N', caso contrário. Haverá vários casos de teste até que as entradas de A e D sejam 0.",
        descricao_solucao: "Para resolver este problema, devemos dar atenção apenas a entrada da distância do atacante mais próximo ao gol e a distância do penúltimo defensor. Ao final da entrada devemos compará-las, caso a distância do defensor seja maior, a resposta será 'Y'. Para se obter o penúltimo defensor (ou seja, o segundo menos distante do gol), precisamos também saber a distância do último.",
        analise: "Para esta solução, o número de operações para cada caso de teste, recebidos no loop da linha 4, depende diretamente dos tamanhos de A e D, visto que existem dois loops para suas entradas nas linhas 5 e 9. Assim, a complexidade de cada caso de teste será de O(n*m), onde n será A + D e m será o número de casos de teste.",
        implementacao: "https://github.com/MadeInUFC/MadeInUFC.github.io/blob/master/roteiros/roteiro3/problemas/problema1/resposta.cpp",
        pseudocodigo:[
          "A, D, menorA, menorD, smenorD, aux, i, j : inteiros",
          "menorA <- menorD <- smenorD <- 0",
          "Leia A e D",
          "Enquanto A != 0 ou D != 0 faça",
          "&emsp; para i <- 0 até A faça",
          "&emsp; &emsp; Leia Aux",
          "&emsp; &emsp; Se menorA = 0 ou aux < menorA então",
          "&emsp; &emsp; &emsp; menorA <- aux",
          "&emsp; para j <- 0 até D faça",
          "&emsp; &emsp; Leia Aux",
          "&emsp; &emsp; Se menorD = 0 então",
          "&emsp; &emsp; &emsp; menorD <- aux",
          "&emsp; &emsp; Senão se aux <= menorD então",
          "&emsp; &emsp; &emsp; smenorD <- menorD",
          "&emsp; &emsp; &emsp; menorD <- aux",
          "&emsp; &emsp; Senão se smenorD = 0 ou aux < smenorD então",
          "&emsp; &emsp; &emsp; smenorD <- aux",
          "&emsp; Se menorA < smenorD faça",
          "&emsp; &emsp; Escreva 'Y'",
          "&emsp; Senão",
          "&emsp; &emsp; Escreva 'N'",
          "&emsp; menorA <- menorD <- smenorD <- 0",
          "&emsp; Leia A e D",          
        ]
    },

      {
        titulo: "Quem vai ser reprovado?",
        titulo_origem: "URI",
        link_origem: " https://www.urionlinejudge.com.br/judge/pt/problems/view/2134",
        nivel: 6,
        status: false,
      },

      {
        titulo: "Proteja sua senha",
        titulo_origem: "URI",
        link_origem: " https://www.urionlinejudge.com.br/judge/pt/problems/view/2287",
        nivel: 6,
        status: false,
      },

      {
        titulo: "Troca de cartas",
        titulo_origem: "URI",
        link_origem: "https://www.urionlinejudge.com.br/judge/pt/problems/view/1104",
        nivel: 4,
        status: true,
        descricao_problema: "O problema consiste em descobrir o número máximo de cartas que duas pessoas podem trocar entre si, sabendo que cada carta possui uma numeração única e os critérios da troca são que as duas pessoas devem fornecer dois subconjuntos de suas cartas de mesmo tamanho, o subconjunto da pessoa A não deve possuir nenhuma carta que esteja no conjunto inicial de B e vice versa. A entrada deve ser em vários casos de testes, com a primeira linha contendo o tamanho do conjunto de A e de B, e as duas linhas seguidas contendo os números de suas cartas em ordem não decrescente. Os casos de testes se encerram quando A e B forem 0.",
        descricao_solucao: "Visto que as entradas das cartas estarão em ordem não decrescente, poderemos usar estruturas de filas para comparar os conjuntos A e B e encontrar uma solução. Com isso, também poderemos ignorar as entradas repetidas dos conjuntos apenas analisando a calda da fila (última a ser inserida) tornando a solução ainda mais simples. Com isso, após a leitura das cartas únicas, deveremos usar duas varáveis 'a' e 'b' para guardar a quantidade de cartas que estarão em A e não em B e vice versa, e então analisaremos a cabeça das duas filas, caso as cartas coincidam, ambas devem ser removidas da fila e não devem ser contabilizadas para troca, caso contrário, aquele conjunto que tiver a carta de menor número possui uma carta que poderá ser trocada com o outro conjunto, sua variável, 'a' ou 'b', deverá ser incrementada e sua cabeça deve ser removida. Caso alguma fila se torne vazia antes que outra, os elementos restantes da fila não vazia devem ser contabilizados como cartas para troca daquele conjunto. Ao fim desse processo, quando as duas filas estiverem vazias, basta retornarmos a menor entre as duas variáveis e então resetá-las para um novo caso de teste.",
        analise: "O número de operações dessa solução depende do loop na linha 4 que etá ligado ao número de casos de testes, aos laços de leitura nas linhas 6 e 10, que dependem respectivamente dos tamanhos de A e B, e do loop da linha 14. Este último depende de uma variável K que corresponde ao tamanho do maior conjunto entre A': A sem repetições, e B': B sem repetições. Assim, a complexidade da solução será em resumo O(m*n), sem 'm' o número de casos de testes e n = |A| + |B| + K.",
        implementacao: "https://github.com/MadeInUFC/MadeInUFC.github.io/blob/master/roteiros/roteiro3/problemas/problema4/resposta.cpp",
        pseudocodigo:[
          "A, B, a, b, aux, i: inteiros",
          "fA, fB: fila de inteiros",
          "Leia A e B",
          "Enquanto A!=0 ou B!=0 faça",
          "&emsp; a <- b <- 0",
          "&emsp; Para i <-0 até A faça",
          "&emsp; &emsp; Leia aux",
          "&emsp; &emsp; Se naoVazia(fA) e aux != fA.calda então",
          "&emsp; &emsp; &emsp; push(fA, aux)",
          "&emsp; Para i <-0 até B faça",
          "&emsp; &emsp; Leia aux",
          "&emsp; &emsp; Se naoVazia(fB) e aux != fB.calda então",
          "&emsp; &emsp; &emsp; push(fB, aux)",
          "&emsp; Enquanto naoVazia(fA) ou naoVazia(fB) faça",
          "&emsp; &emsp; Se Vazia(fA) então",
          "&emsp; &emsp; &emsp; b <- b + 1",
          "&emsp; &emsp; &emsp; Pop(fB)",
          "&emsp; &emsp; Senão se Vazia(fB) então",
          "&emsp; &emsp; &emsp; a <- a + 1",
          "&emsp; &emsp; &emsp; Pop(fA)",
          "&emsp; &emsp; Senão",
          "&emsp; &emsp; &emsp; Se fA.cabeça = fB.cabeça então",
          "&emsp; &emsp; &emsp; &emsp; Pop(fB)",
          "&emsp; &emsp; &emsp; &emsp; Pop(fA)",
          "&emsp; &emsp; &emsp; Senão se fA.cabeça > fB.cabeça então",
          "&emsp; &emsp; &emsp; &emsp; b <- b + 1",
          "&emsp; &emsp; &emsp; &emsp; Pop(fB)",
          "&emsp; &emsp; &emsp; Senão",
          "&emsp; &emsp; &emsp; &emsp; a <- a + 1",
          "&emsp; &emsp; &emsp; &emsp; Pop(fA)",
          "&emsp; Se a < b Escreva a",
          "&emsp; Sentão Escreva b",
          "&emsp; Leia A e B",          
        ]
      },

      {
        titulo: "Mário",
        titulo_origem: "URI",
        link_origem: "https://www.urionlinejudge.com.br/judge/pt/problems/view/1408",
        nivel: 6,
        status: false,
      },

      {
        titulo: "Triângulos",
        titulo_origem: "URI",
        link_origem: "https://www.urionlinejudge.com.br/judge/pt/problems/view/1472",
        nivel: 6,
        status: false,
      },

      {
        titulo: "Grid de Largada",
        titulo_origem: "URI",
        link_origem: "https://www.urionlinejudge.com.br/judge/pt/problems/view/1228",
        nivel: 3,
        status: true,
        descricao_problema: "Dados um número A de piloto, a ordem de largada dos A pilotos no grid, onde os pilotos são identificados com números de 1 a A, e a ordem de chegada desses pilotos, deve-se retornar o número mínimo de ultrapassagens entre a largada e a chegada. Havará multiplos casos de teste enquanto houver um valor para A.",
        descricao_solucao: "Para isso, podemos analisar, em ordem, os pilotos na chegada e compará-los com a ordem da largada. Caso um piloto permaneça na mesma posição, ele não acrescentará ao resultado de ultrapassagens, portanto poderá ser descartado na lista de largada e chegada. Caso contrário, devemos incrementar em 1 o número de ultrapassagens até encontrar o antigo valor do piloto e então removê-lo das listas para continuar a contagem e restaurar as posições anteriores. Assim, poderemos usar uma fila para as entradas da chegada, uma vez que analisaremos os pilotos em ordem, e um vetor para as entradas de largada. Manipularemos esse vetor com ponteiros e com inserção de 0s nos pilotos removidos.",
        analise: "Nesta solução, teremos que no melhor caso, onde a ordem de largada é a mesma de chegada, para cada caso de teste o número de operações no algoritmo dependerá de A, pois o laço na linha 9 se encerrará após A operações de pop na fila de chegada. Assim teremos um tempo linear. Ja no pior caso, onde a ordem de chegada é o contrário da ordem de largada, teremos um número maior de operações, pois o primeiro elemento da fila estará no laço A vezes até sua remoção, o segundo estará A - 1 vezes e assim por diante.",
        implementacao: "https://github.com/MadeInUFC/MadeInUFC.github.io/blob/master/roteiros/roteiro3/problemas/problema7/resposta.cpp",
        pseudocodigo:[
          "A, aux, j, k, ultrapassagens: inteiro",
          "grid: vetor de inteiros",
          "chegada: fila de inteiros",
          "Leia A",
          "Enquanto A, faça",
          "&emsp; criarVetor(grid, A)",
          "&emsp; criarFila(chegada, A)",
          "&emsp; j <- k <- ultrapassagens <- 0",
          "&emsp; Enquanto estaVazia(chegada) faça",
          "&emsp; &emsp; aux <- chegada.cabeça",
          "&emsp; &emsp; Se j = k então",
          "&emsp; &emsp; &emsp; j <- j + 1",
          "&emsp; &emsp; &emsp; k <- k + 1",
          "&emsp; &emsp; &emsp; Pop(chegada)",
          "&emsp; &emsp; Senão se grid[j] != 0 faça",
          "&emsp; &emsp; &emsp; k <- k + 1",
          "&emsp; &emsp; &emsp; ultrapassagens <- ultrapassagens + 1",
          "&emsp; &emsp; Senão então",
          "&emsp; &emsp; k <- j <- j + 1",
          "&emsp; Senão",
          "&emsp; &emsp; Se grind[k] = aux então",
          "&emsp; &emsp; &emsp; grid[k] <- 0 ",
          "&emsp; &emsp; &emsp; k <- j",
          "&emsp; &emsp; &emsp; Pop(chegada)",
          "&emsp; &emsp; Senão se grid[k] = 0 então",
          "&emsp; &emsp; &emsp; k <- k + 1",
          "&emsp; &emsp; Senão então",
          "&emsp; &emsp; &emsp; k <- k + 1",
          "&emsp; &emsp; &emsp; ultrapassagens <- ultrapassagens + 1",
          "&emsp; &emsp; Retorne ultrapassagens",           
        ]
      },

      {
        titulo: "Subsequências",
        titulo_origem: "URI",
        link_origem: "https://www.urionlinejudge.com.br/judge/pt/problems/view/1507",
        nivel: 5,
        status: false,
      },

      {
        titulo: "Trilhos",
        titulo_origem: "URI",
        link_origem: "https://www.urionlinejudge.com.br/judge/pt/problems/view/1062",
        nivel: 4,
        status: false,
      },
      
    ]
  }